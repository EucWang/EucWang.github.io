<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>仗剑浆糊</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://newyearwang.com/"/>
  <updated>2020-01-02T13:22:53.993Z</updated>
  <id>http://newyearwang.com/</id>
  
  <author>
    <name>newyear</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>kotlin基础语法(一)</title>
    <link href="http://newyearwang.com/2020/01/02/kotlin%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95-%E4%B8%80/"/>
    <id>http://newyearwang.com/2020/01/02/kotlin基础语法-一/</id>
    <published>2020-01-02T13:10:26.000Z</published>
    <updated>2020-01-02T13:22:53.993Z</updated>
    
    <content type="html"><![CDATA[<h1 id="helloworld"><a href="#helloworld" class="headerlink" title="helloworld"></a>helloworld</h1><a id="more"></a><p><img src="/images/helloWorld.png" alt></p><h1 id="kotlin的特征"><a href="#kotlin的特征" class="headerlink" title="kotlin的特征"></a>kotlin的特征</h1><ol><li><p>野心很大, 替代java, 更简洁, 更高效, 更安全, 全平台支持</p><ul><li>android</li><li>服务器端</li><li>kotlin可以编译成Javascript </li><li>kotlin/原生  对c/c++/oc/swift的双端互操作</li></ul></li><li><p>和java一样是静态类型的编程语言, 所有表达式的类型在编译期就确定了, 这个和Groovy,JRuby这些动态类型的语言是不同的. 虽然kotlin不用显示的声明变量类型.</p></li><li><p>函数式和面向对象</p><ul><li>头等函数, 函数可以作为值来使用, 可以作为参数传递,可以作为函数的返回值</li><li>不可变对象</li><li>纯函数.输入相同时返回相同的结果.</li><li>lambda表达式</li><li>语法糖<br>务实/简洁/安全/互操作行</li></ul></li></ol><h1 id="kotlin基础"><a href="#kotlin基础" class="headerlink" title="kotlin基础"></a>kotlin基础</h1><h2 id="函数和变量"><a href="#函数和变量" class="headerlink" title="函数和变量"></a>函数和变量</h2><ol><li><p>main函数</p><pre><code>/*** fun: 函数声明的关键字* 参数的类型写在参数的后面, 变量的声明也是这样* println替代 System.out.println.  这是对java的一层包装* 函数可以定义在文件的最外层, 不需要在类中* 省略行尾的分号*/fun main(args: Array<string>) {printlin("Hello, world!")}</string></code></pre></li><li><p>带返回值的函数 和 语句表达式</p><pre><code>/*** 返回值的类型 在参数列表后面声明, 以 ":"分开* 在kotlin中if是表达式,而不是语句, 表达式有返回值,可以包含在其他表达式中,* 在kotlin中,除了循环(for, while, do/while)之外,其他语句基本都是表达式* kotlin中没有三元表达式( a>b ? a : b)*/fun max(a: Int, b: Int) : Int { return if (a > b) a else b    }</code></pre></li><li><p>表达式函数体</p><pre><code>/*** 函数体由单个表达式构成的,可以简化return和花括号*/fun max(a: Int, b: Int) : Int = if (a > b) a else b</code></pre></li></ol><pre><code>/** *表达式函数体可以省略返回类型声明 */fun max(a: Int, b: Int) = if (a > b) a else b</code></pre><ol start="4"><li>变量 (不可变变量val , 可变变量var)<pre><code>//这里是String类型val question = "The Ultimate Question of Life, the Universe, and Everything"</code></pre></li></ol><p>//推断为Int<br>val answer = 42</p><p>//明确指定为Int类型<br>val answer2 : Int = 42</p><p>//自动推断为Double类型, 因为用的是浮点常量<br>val yearsToComputer = 7.5e6 // 7.5 * 10e6</p><p>//在定义val变量的代码块执行期间, 根据条件使用不同值能确保唯一一次初始化<br>val message: String<br>if(canPerformOperation()) {<br>    message = “Success”<br>} else {<br>    message = “Failed”<br>}</p><p>//声明的是不可变对象, 对象的引用不可变,但是对象本身的内容是可变的<br>val languages = arrayListOf(“Java”)<br>languages.add(“Kotlin”)</p><p>//可变变量<br>var answer = 42      //自动推断为Int型, 之后answer变量的类型不可变<br>answer = “no answer”  //会报错, 类型不匹配<br></p><ol start="5"><li>字符串模板<pre><code>val name = "zhang san"println("Hello, $name!")   //单个参数的字符串模板</code></pre></li></ol><p>val args = arrayOf(“zhangsan”,  “lisi”, “wangwu”)<br>println(“Hello, ${args[0]}!”)   //可以是这样简单的</p><p>//也可以是这么复杂的<br>println(“Hello, ${if (args.size &gt; 0) args[0] else “someone”}!”) </p><p>println(“$100,000,000,000”)  //如果单纯就想输出$符, 得转义下<br></p><h2 id="类和属性"><a href="#类和属性" class="headerlink" title="类和属性"></a>类和属性</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ol><li>kotlin中, 属性默认是public 的, 在java中可以直接访问kotlin里对象的访问器</li></ol><pre><code>//kotlin中定义的类class Person(    val name:String,     //只读属性, 一个字段,一个getter    var isMarried:Boolean)   //可写属性,  一个字段, getter/setter//在java中使用Person a = new Person("zhangsan", false);a.setMarried(true);System.out.println("name : " + a.getName() + ", married : " + a.isMarried());</code></pre><ol start="2"><li>自己定义访问器<pre><code>/**自己定义访问器, 长方形, 自定义一个判断是否是矩形的getter*/class Rectangle(val height: Int, val width: Int) { val isSquare:Boolean   //增加一个属性, 并配置其访问器getter, 没有字段存储     get(){         return height == width     }}</code></pre></li></ol><p>//可以简写成如下:<br>class Rectangle(val height: Int, val width: Int) {<br>    val isSquare:Boolean<br>        get() = (height == width)<br>}<br></p><h3 id="目录和包"><a href="#目录和包" class="headerlink" title="目录和包"></a>目录和包</h3><ol><li>kotlin文件中能以一条 package语句开头,声明文件中的都放到这个包中</li><li>两个文件可以声明成同一个包名, kotlin声明的包层级结构不需要和实际的文件目录结构相同,建议不用这样玩, 除非是特别小的类</li><li>不同的包名的声明, 使用时需要import导入, “.*” 导入全部</li><li>kotlin的import导入不区分类和函数</li></ol><h2 id="枚举-转换-when"><a href="#枚举-转换-when" class="headerlink" title="枚举, 转换, when"></a>枚举, 转换, when</h2><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><ol><li><p>和java的枚举的不同</p><pre><code>//kotlin中的枚举enum class Color{ RED, ORANGE, YELLOW, GREEN, BLUE, INDIGO, VIOLET}//java中的枚举enum class { RED, ORANGE, YELLOW, GREEN, BLUE, INDIGO, VIOLET}</code></pre></li><li><p>声明带属性的枚举, 同java, 注意kotlin中唯一必须使用”;” 的情况</p><pre><code>/**枚举类*/enum class Color( val r : Int, val g : Int, val b : Int) { RED(255, 0, 0), ORANGE(255,265, 0), YELLOW(255,255, 0), GREEN(0,255,0), BLUE(0,0,255), INDIGO(75,0,130),  VIOLET(238, 130,238);   //☢注意: 这里必须要有分号 fun rgb()  = (r * 256 + g) * 256  + b}</code></pre></li></ol><h3 id="使用when-处理枚举"><a href="#使用when-处理枚举" class="headerlink" title="使用when 处理枚举"></a>使用when 处理枚举</h3><pre><code> /**when可以是一个有返回值的表达式,代替java中的switch,break*/fun getMnemonic(color: Color) =    when(color) {        Color.RED, Color.ORANGE -> "Of"   //"," 处理多个值合并到同一个分支        Color.YELLOW -> "York"        Color.GREEN -> "Gave"        Color.BLUE -> "Battle"        Color.INDIGO -> "In"        Color.VIOLET -> "Vain"    }</code></pre><ol><li><p>在when中使用任意对象, 比switch强大,switch要求必须是常量</p><pre><code>/**这里处理颜色的set集合, set中元素顺序不重要,只要包含一样的条目,就是相等的*/fun mix(c1: Color,  c2 : Color)  = when(setOf(c1, c2)) {     setOf(RED, YELLOW) -> ORANGE     setOf(YELLOW, BLUE) -> GREEN     setOf(BLUE, VIOLET) -> INDOGO     else -> throw Exception("Dirty Color")  //结合else处理其他 的情况,这里抛异常 }</code></pre></li><li><p>使用不带参数的when,</p><pre><code>/**when的分支判断条件不仅仅是等式检查, 可以是任意的布尔表达式*/fun mixOptimized(c1: Color, c2: Color) = when {     (c1 == RED && c2 == YELLOW) ||     (c1 == YELLOW && c2 == RED) -> ORANGE  //这里不会创建多个set集合     (c1 == YELLOW && c2 == BLUE) ||     (c1 == BLUE && c2 == YELLOW) -> GREEN     (c1 == BLUE && c2 == VIOLET) ||     (c1 == VIOLET && c2 == BLUE) -> INDIGO     else -> throw Exception("Dirty color") }</code></pre></li></ol><h3 id="类型检查和转换-is-as"><a href="#类型检查和转换-is-as" class="headerlink" title="类型检查和转换 (is,  as)"></a>类型检查和转换 (is,  as)</h3><pre><code>interface Expr                                           //接口class Num(val value: Int) : Expr                         //接口的实现类Numclass Sum(val left: Expr, val right: Expr) : Expr        //接口的实现类Sumfun eval(e : Expr) : Int {    if (e is Num) {               //is 类似于 java中的: instanceOf,         val n = e as Num     //强制转换了 类似于java中的: Num n = (Num)e        return n.value    } else if(e is Sum) {      //在类型判断成功的时候,kotlin就自动进行类型转换了,就不需要转换它了        //☢注意,智能转换的对象的属性,必须是一个val属性,且不能有自定义访问器,防止发生变化        return eval(e.right) + eval(e.left)  //递归调用    }    throw IllegalArgumentException("Unknown expression")}//对eval函数使用when重写(也可以用if来简化重写):fun eval(e : Expr): Int =     when (e) {        is Num -> e.value        is Sum -> eval(e.right) + eval(e.left)        else -> throw IllegalArgumentException("Unknown expression")    }</code></pre><h3 id="代码块-作为-if-和-when-的分支"><a href="#代码块-作为-if-和-when-的分支" class="headerlink" title="代码块{}作为 if  和 when 的分支"></a>代码块{}作为 if  和 when 的分支</h3><figure class="highlight plain"><figcaption><span>这个规则对于try主体和catch子句依然有效```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;pre&gt;&lt;code&gt;/***/</span><br><span class="line">fun evalWithLogging(e: Expr) : Int = </span><br><span class="line">    when(e) &#123;</span><br><span class="line">        is Num -&gt; &#123;</span><br><span class="line">            println(&quot;num: $&#123;e.value&#125;&quot;)</span><br><span class="line">            e.value   //代码块中的最后一个表达式会默认最为返回值</span><br><span class="line">        &#125;</span><br><span class="line">        is Sum -&gt;&#123;</span><br><span class="line">            val left = evalWithLogging(e.left)</span><br><span class="line">            val right = evalWithLogging(e.right)</span><br><span class="line">            println(&quot;sum: $left + $right&quot;)</span><br><span class="line">            left+right   //代码块中的最后一个表达式会默认最为返回值</span><br><span class="line">        &#125;</span><br><span class="line">        else -&gt; throw IllegalArgumentException(&quot;Unknown expression&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">## 循环迭代  while , for</span><br><span class="line"></span><br><span class="line">### while, do...while</span><br><span class="line">同java</span><br><span class="line"></span><br><span class="line">### 区间, 数列</span><br></pre></td></tr></table></figure><p>kotlin中没有”java中的for循环”, 使用区间的概念替代</p><p>区间: 本质就是两个值之间的间隔, 两个值通常是数字: 一个起始值, 一个结束值, 使用 “..”运算符表示区间:<br>val oneToTen = 1..10<br>注意☢：kotlin区间是包含的或者是闭合的, 第二个值始终是区间的一部分</p><p>数列: 就是区间, 能够迭代区间中所有的值的区间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;pre&gt;&lt;code&gt;</span><br><span class="line">fun fizzBuzz(i: Int) = when &#123;</span><br><span class="line">    i % 15 == 0 -&gt; &quot;FizzBuzz&quot;</span><br><span class="line">    i % 3 == 0 -&gt; &quot;Fizz&quot;</span><br><span class="line">    i % 5 == 0 -&gt; &quot;Buzz&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(i in 1..100) &#123;                                 // 注意： ☢写法不同  ☢关键字 in</span><br><span class="line">    println(fizzBuzz(i))  //在区间1...100,包括100迭代</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (i in 100 downTo 1 step 2) &#123;</span><br><span class="line">     println(fizzBuzz(i))   //在区间 100..1 , 步长为2,倒序输出  ,, 关键字 downTo, step</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val size = 100</span><br><span class="line">for (x in 0 until size) &#123;      //这种应该更接近常用的java的for循环写法      ☢注意写法</span><br><span class="line">    println(fizzBuzz(x))     //until关键字表示半闭合区间, 不包括最后一个值 ,, 关键字  until</span><br><span class="line">&#125;</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">### 使用for迭代map集合</span><br><span class="line">&lt;pre&gt;&lt;code&gt;</span><br><span class="line">val binaryReps = TreeMap&lt;Char, String&gt;()  //TreeMap集合, 有顺序</span><br><span class="line"></span><br><span class="line">for(c in &apos;A&apos;..&apos;F&apos;) &#123;       //  &quot;..&quot;语法也可以用来创建字符区间</span><br><span class="line">    val binary = Integer.toBinaryString(c.toInt())  //字符转成Int,然后得到其二进制形式的字符串</span><br><span class="line">    binaryReps[c] = binary       //以数组的形式来操作map集合, 而不需要调用get,put方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for((letter, binary) in binaryReps) &#123;   //使用for循环遍历map集合, 把map的键,值分别赋值给两个变量</span><br><span class="line">    println(&quot;$letter = $binary&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//扩展, 获取两个变量的迭代形式,也可以用于list的遍历</span><br><span class="line">val list = arrayListOf(&quot;10, &quot;11&quot;, &quot;1001&quot;)</span><br><span class="line">for((index, element) in list.withIndex()) &#123;   //使用下标迭代, 注意☢withIndex()方法: 获取下标和元素</span><br><span class="line">    println(&quot;$index, $element&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">### in关键字,也可以用于检查集合和区间的成员</span><br></pre></td></tr></table></figure><p>使用in运算符来检查一个值是否在区间中,<br>或者它的逆运算 !in 来检查一个值是否不在区间中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;pre&gt;&lt;code&gt;//是否是字母的字符 </span><br><span class="line">fun isLetter(c: Char) = </span><br><span class="line">    (c in &apos;a&apos;..&apos;z&apos; ||</span><br><span class="line">    c in &apos;A&apos;..&apos;Z&apos;)  </span><br><span class="line"></span><br><span class="line">//是否不是数字的字符</span><br><span class="line">fun isNotDigit(c: Char) = </span><br><span class="line">    c !in &apos;0&apos;..&apos;9&apos;</span><br><span class="line"></span><br><span class="line">//in 检查同样适用于集合</span><br><span class="line">println(&quot;Kotlin&quot; in setOf(&quot;Java&quot;, &quot;Scala&quot;))</span><br><span class="line"></span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">## kotlin中的异常</span><br><span class="line"></span><br><span class="line">和java的处理方式类似</span><br><span class="line">不同点:</span><br><span class="line">1. kotlin中的throw结构是个表达式,能作为另一个表达式的一部分, 同样try/catch也是表达式</span><br><span class="line">2. kotlin不区分受检异常和未受检异常</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code&gt;</span><br><span class="line">fun readNumber(reader: BufferedReader) &#123;</span><br><span class="line">    val number = try&#123;</span><br><span class="line">        Integer.parseInt(reader.readLine())  //没有异常时,使用这个值</span><br><span class="line">    &#125; catch(e: NumberFormatException) &#123;</span><br><span class="line">        println(e.message)</span><br><span class="line">        null                                                  //有异常时,使用这个值</span><br><span class="line">    &#125;</span><br><span class="line">    println(number)</span><br><span class="line">&#125;</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 函数的定义和调用</span><br><span class="line"></span><br><span class="line">## 在kotlin中创建集合</span><br></pre></td></tr></table></figure><p>kotlin采用的还是java的集合类, 在java类的基础上进行了封装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;pre&gt;&lt;code&gt;</span><br><span class="line">val set = hashSetOf(1, 7 ,53)   //返回HashSet</span><br><span class="line"></span><br><span class="line">val list = arrayListOf(1, 7, 53)   //返回ArrayList</span><br><span class="line"></span><br><span class="line">//注意☢：关键字 to ，是一个函数,  a.to(b) 形式的简写形式,  返回包含key/value的一个实体</span><br><span class="line">val map = hashMapOf(1 to &quot;one, 7 to &quot;seven&quot;, 53 to &quot;fifty-three&quot;)  //返回HashMap</span><br><span class="line"></span><br><span class="line">println(list.last())    //last()获得最后一个元素</span><br><span class="line">println(list.max())   //max()获得最大的一个元素</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">## 更好的函数调用</span><br><span class="line">``` (以格式化显示集合元素的方法作为例子)</span><br></pre></td></tr></table></figure><pre><code>/**按照格式输出一个集合中的全部元素*/fun <t> joinToString(    collection : Collection<t>,       //需要显示的集合    separator: String,    //分割符    prefix : String,         //前缀字符串    postfix: String)        //后缀字符串    : String {                 //返回类型String    val result = StringBuilder(prefix)                   for((index, element) in collection.withIndex()) {   //带索引的遍历集合        if(index > 0) result.append(seperator)            //添加分隔符到StringBuilder中        result.append(element)                                     }    result.append(postfix)    return result.toString()   }va list = listOf(1,2,3,4)println(list, ", ",  "(", ")")//控制台输出//(1, 2, 3)</t></t></code></pre><h3 id="命名参数"><a href="#命名参数" class="headerlink" title="命名参数"></a>命名参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">调用kotlin函数时,可以显式标明一些参数的名称</span><br><span class="line">如果在调用一个函数时,指定了一个参数的名称, </span><br><span class="line">为了避免混淆, 那它之后的所有参数都需要标明名称</span><br></pre></td></tr></table></figure><pre><code>joinToString(list,  separator=" ", prefix=" ", postfix= "."  )</code></pre><h3 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kotlin的默认参数可以避免java中过多的重载函数</span><br><span class="line">1. 如果有多个带默认值的参数, 配合命名参数一起使用,  可以省略中间的部分参数</span><br><span class="line">2. 当用java调用kotlin方法时,必须显式的指定全部参数值. 除非使用了@JvmOverloads注解了方法,编译器才会生成多个重载方法供java使用</span><br></pre></td></tr></table></figure><pre><code>//重新声明函数, 使用默认参数fun <t> joinToString(    collection : Collection<t>,    separator : String = ", ",          //有默认值的参数, 在调用时,就可以省略这些参数的传值    prefix : String = "",    postfix : String = "") : String {    ...}</t></t></code></pre><h3 id="顶层函数和属性"><a href="#顶层函数和属性" class="headerlink" title="顶层函数和属性"></a>顶层函数和属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">目的: 消灭静态工具类</span><br><span class="line">java项目中必然存在很多工具类,因为很多方法并不归属于任何一个类中</span><br><span class="line">1. 可以将kotlin中的函数直接位于文件顶层,而不需要放置在类中,不用写成 public static void method(..)&#123;..&#125;</span><br><span class="line">2. kotlin中的顶层函数都会编译成静态函数,类名就是文件名, 在java可以直接调用</span><br><span class="line">3. 注解@file:JvmName(&quot;StringFunctions&quot;)位于文件开头, 位于包名前面, 可以修改顶层函数生成的类的名称</span><br><span class="line"></span><br><span class="line">4. 属性也可以放置在文件的顶层, 作为一个静态的字段, 可以用val, var修饰, 表示final的, 非final的</span><br><span class="line">5. 顶层属性可以使用const来修饰, 表示一个常量</span><br></pre></td></tr></table></figure><h2 id="扩展函数和属性"><a href="#扩展函数和属性" class="headerlink" title="扩展函数和属性"></a>扩展函数和属性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">扩展函数:  一个类的成员函数, 不过是定义在了类的外面, 其实实质上是一个静态函数, </span><br><span class="line">就是静态函数的一个高效的语法糖</span><br><span class="line"></span><br><span class="line"> 1. 要扩展的类或者接口的名称,放到需要添加的函数前面, 这就是接受者的类型</span><br><span class="line"> 2. 用来调用这个扩展函数的那个对象, 叫做接受者对象, 函数体中的this就是接受者对象</span><br><span class="line"> 3. 扩展函数不能访问私有的或者是受保护的成员,不允许打破它的封装性</span><br><span class="line"> 4. 扩展函数需要独立于接受者类型单独的导入</span><br><span class="line"> 5. 为了解决命名冲突, 可以使用关键字 as 来修改导入的类或者函数的名称, 这是唯一方式</span><br><span class="line"> 6. java中调用扩展函数, 和调用顶层函数是一样调用</span><br><span class="line"> 7. 因为扩展函数是静态的, 所以 扩展函数时不能被子类重写的</span><br><span class="line"></span><br><span class="line">kotlin对java集合的新增加的API, 都是通过扩展函数的来实现的</span><br><span class="line">比如:  last() ,  max() 等函数</span><br></pre></td></tr></table></figure><p>一个简单的扩展函数</p><pre><code>package strings   //包名fun String.lastChar() : Char     = this.get(this.length - 1)println("Kotlin".lastChar())</code></pre><pre><code>import strings.lastChar as last   //导入并改变函数的名称val c = "Kotlin".last()</code></pre><h3 id="joinToString函数的终极版本"><a href="#joinToString函数的终极版本" class="headerlink" title="joinToString函数的终极版本"></a>joinToString函数的终极版本</h3><pre><code>fun <t> Collection<t>.joinToString(    separator: String=", ",    prefix : String = "",    postfix: String = ""): String {    val result = StringBuilder(prefix)    for((index, element) in this.withIndex()) {        if(index > 0) result.apend(separator)        result.append(element)    }    result.append(postfix)    return result}</t></t></code></pre><h3 id="扩展属性"><a href="#扩展属性" class="headerlink" title="扩展属性"></a>扩展属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">尽管称为属性, 其实没有任何状态, 也没有合适的地方存储它</span><br><span class="line">扩展属性必须自定义getter函数, 也没办法初始化,  因为没有支持字段</span><br></pre></td></tr></table></figure><pre><code> //声明一个可变的扩展属性var StringBuild.lastChar : Char           //扩展属性, 方式类似于扩展函数    get() =                               //自定义其getter()        get(length - 1)    set(value: Char) {                    //自定义其setter()        this.setCharAt(length - 1, value)    }</code></pre><h2 id="可变参数-中缀调用-集合处理"><a href="#可变参数-中缀调用-集合处理" class="headerlink" title="可变参数, 中缀调用, 集合处理"></a>可变参数, 中缀调用, 集合处理</h2><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">可变参数关键字 vararg,可以用来声明一个函数可以有任意数量的参数,</span><br><span class="line">java中是使用&quot;...&quot;三个点表示可变参数, kotlin中使用vararg修饰符</span><br><span class="line">在函数中使用时, 还需要显式的解包可变参数为数组,以便每个元素都能单独使用, </span><br><span class="line">方法就是在对应的参数前面加一个 *</span><br></pre></td></tr></table></figure><pre><code> //listOf函数的声明fun listOf<t>(vararg values: T): List<t>{    ...}//展开运算符展开数组内容fun main(args: Array<string>){    val list = listOf("args: ",  *args)   //注意这里的"*"号    println(list)}</string></t></t></code></pre><h3 id="中缀调用-和解构声明"><a href="#中缀调用-和解构声明" class="headerlink" title="中缀调用 和解构声明"></a>中缀调用 和解构声明</h3><pre><code>val map = mapOf(1 to "one",  7 to "seven", 53 to "fifty-three")</code></pre><p>关键字 to, 是一种特殊的函数调用, 被称为 “中缀调用”</p><pre><code>//这两种调用方式是等价的1.to("one")  1 to "one"</code></pre><p>使用关键字 infix来标记中缀调用函数</p><pre><code>//一个简单的to函数声明infix fun Any.to(other: Any)    = Pair(this, other)    //返回一个Pair类型的对象, 表示一对元素, kotlin定义的类// 这里直接用Pair的内容来初始化这两个变量val (number, name) = 1 to "one"// map的key,value的内容 适用于 解构声明特征//同样, 集合调用withIndex()函数之后的结果一样适用于 解构声明特征</code></pre><h2 id="字符串和正则表达式的处理"><a href="#字符串和正则表达式的处理" class="headerlink" title="字符串和正则表达式的处理"></a>字符串和正则表达式的处理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kotlin字符串和java字符串完全相同,</span><br><span class="line">kotlin还提供了一系列有用的扩展函数来扩展String的操作</span><br></pre></td></tr></table></figure><pre><code>//java中的split()方法接受的字符串是正则表达式,kotlin对这个方法进行的重载//接受正则表达式的值需要一个Regex类型,//接受一般的字符串的就是正常的分割//toRegex() 扩展函数将字符串转换成正则表达式Regexprintln("12.345-6.A".split("\\.|-".toRegex()))//split接受多个参数, 指定多个分隔符println("12.345-6.A".split(".", ","))fun parsePath(path: String) {    val dir = path.substringBeforeLast("/")           //几个String的扩展函数    val fullName = path.substringAfterLast("/")    val fileName = fullName.substringBeforeLast(".")    val extension = fullName.substringAfterLast(".")} //三重引号的字符串, 不需要对任何字符进行转义,包括反斜线fun parsePath(path: String) {    val regex  = """(.+)/(.+)\.(.+)""".toRegex()      val  matchResult = regex.matchEntire(path)    if(matchResult != null) {        val (dir, fileName, extension) = matchResult.destructured        println("Dir: $dir, name: $fileName, ext: $extension")    }}//多行三重引号之间的所有字符,包括空白, 索引val kotlinLogo = """| //                               .|//                               .|/\"""</code></pre><h2 id="局部函数和扩展"><a href="#局部函数和扩展" class="headerlink" title="局部函数和扩展"></a>局部函数和扩展</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在函数中声明的函数, 就是局部函数</span><br><span class="line">局部函数可以访问所在函数中的所有参数和变量</span><br></pre></td></tr></table></figure><pre><code>class User(val id: Int,    val name: String,    val address: String)fun saveUser(user: User) {    fun validate(value: String, fieldName: String) {        if(value.isEmpty()) {            throw IllegalArgumentException("cannot save user ${user.id}: empty ${fieldName}")        }    }    validate(user.name, "Name")    validate(user.address, "Address")    }</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;helloworld&quot;&gt;&lt;a href=&quot;#helloworld&quot; class=&quot;headerlink&quot; title=&quot;helloworld&quot;&gt;&lt;/a&gt;helloworld&lt;/h1&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>C预处理器</title>
    <link href="http://newyearwang.com/2019/09/21/C%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E5%99%A8/"/>
    <id>http://newyearwang.com/2019/09/21/C预处理器器/</id>
    <published>2019-09-21T09:08:30.000Z</published>
    <updated>2019-09-21T09:25:43.153Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>看着C Primer Plus 第16章，复习一下C预处理这一部分知识。 以前学习C语言的时候，对预处理器这一部分很是瞧不起，这有啥呢，无非就是在编译之前做一下字符串替换而已，没有什么技术含量啊。然而事实上是，技术无论好坏高低，能有效且快速解决各种实际问题的才会最终留到最后，C语言的预处理器就属于这种看起来low，但是实际用处非常大的一种功能。</p></blockquote><p>预处理器不仅仅是做了符号替换，还可以根据要求包含其他的文件，可以选择让编译器处理那些代码。虽然预处理器不能理解C，但是扩展的一些预处理器指令还是非常实用。温故而知新，从符号替换开始捋一下。</p><a id="more"></a><h2 id="基础的处理"><a href="#基础的处理" class="headerlink" title="基础的处理"></a>基础的处理</h2><ol><li><p>对于较长的字符串，可以多行显示， 使用”&quot;来折行， 在预处理阶段，会转换成一个完整的字符串</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"That's wond\</span></span><br><span class="line"><span class="string">erful!\n"</span>);</span><br></pre></td></tr></table></figure></li><li><p>对于代码中的注释，会用空格字符替换</p></li></ol><h2 id="第一个预处理指令-define"><a href="#第一个预处理指令-define" class="headerlink" title="第一个预处理指令 #define"></a>第一个预处理指令 #define</h2><p>每一个#define由三部分组成，第一部分就是#define自身，第二部分，是所定义的宏(macro)， 宏名称不允许出现空格，只能使用字母，下划线和数字，第一个字符不能是数字。第三部分成为替换列表(replacement list)或者主体(body),也就是在程序中宏定义被替换之后的内容。 </p><p>一般而言，预处理器发现程序中的宏之后，会用它的等价替换文本代替宏。如果该字符串中还包括宏，则继续替换这些宏。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个折行的字符串</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OW <span class="meta-string">"Consistency is the last refuge of the unimagina\</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">tive. - Oscar Wilde"</span></span></span><br><span class="line"><span class="comment">//定义一个常量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TWO 2</span></span><br><span class="line"><span class="comment">//宏定义中可以包含其他宏</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOUR TWO * TWO</span></span><br><span class="line"><span class="comment">//宏定义成一个语句</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PX printf(<span class="meta-string">"x is %d.\n"</span>, x)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LIM = <span class="number">5</span>;  <span class="comment">//定义const常量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = TWO;  <span class="comment">//TWO 在编译之前会被替换成2</span></span><br><span class="line">    <span class="keyword">int</span> y = FOUR; <span class="comment">//FOUR 在编译之前首先被替换成TWO*TWO，然后再次被替换成2*2</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(OW); <span class="comment">//宏展开成一个字符串</span></span><br><span class="line">    PX;         <span class="comment">//宏展开之后就是一个printf语句了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态局部变量存储于进程的全局数据区，即使函数返回，它的值也会保持不变。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> data[LIM]; <span class="comment">//c11无效</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> data0[TWO]; <span class="comment">//c11有效</span></span><br><span class="line">    <span class="keyword">int</span> data2[LIM];       <span class="comment">//c11有效</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>宏定义的符号常量基本上和const定义的常量效果一样。使用const可以创建全局常量和局部常量，数字常量，数组常量和结构常量。c11标准中目前看来只在静态局部数组初始化时，const的变量会编译报错，这个和《c primer plus 第五版》中还是有点不同。</p><h3 id="语言符号"><a href="#语言符号" class="headerlink" title="语言符号"></a>语言符号</h3><p>从技术上讲，系统把宏主体作为<strong>语言符号类型的字符串</strong>来处理的，而不是字符型字符串。比较如下2个定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">define FOUR <span class="number">2</span>*<span class="number">2</span></span><br><span class="line">define SIX <span class="number">2</span> * <span class="number">3</span></span><br></pre></td></tr></table></figure><p>如果用字符型字符串的观点看，空格也应该是宏主体的一部分，例如上面的第二个定义；而如果用语言符号字符串的观点看，那么宏主体就是包含多个语言符号，多个语言符号用空格分开。实际上，有部分编译器是把宏主体作为字符型字符串而不是语言符号型字符串来处理的。再更复杂的宏定义中，这种差别才会有所体现。(<em>太深入的细节，这本书也没有讲</em>)。</p><h3 id="在-define中使用参数"><a href="#在-define中使用参数" class="headerlink" title="在#define中使用参数"></a>在#define中使用参数</h3><p>带参数的宏，可以有多个参数，用逗号分开，宏的参数用圆括号括起来，然后在宏的主体中使用这些参数即可。使用时，和方法调用相同，但是表现出来的行为并不完全相同。因为宏调用是把参数的语言符号传递给程序，宏实体是计算类型的表达式时，有可能改变计算的优先级；而且如果参数本身也是一把计算表达式的话，(<em>例如x++,x–等</em>)有可能导致表达式会计算多次，导致其他问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SQUARE(x) ((x)*(x))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在程序中使用</span></span><br><span class="line"><span class="keyword">int</span> z = SQUARE(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>所以，使用带参数的宏定义时，最好这样做：</p><ol><li>使用尽可能多的圆括号来保证以正确的顺序进行运算。</li><li>不要在使用宏定义方法时，在参数中使用自增，自减等会导致变量发生改变的表达式。</li></ol><h4 id="使用-运算符让参数在实体中拼接字符串"><a href="#使用-运算符让参数在实体中拼接字符串" class="headerlink" title="使用#运算符让参数在实体中拼接字符串"></a>使用#运算符让参数在实体中拼接字符串</h4><p>如果宏定义中x 是一个宏参数，在宏实体中，在双引号中不能直接使用x，需要使用#x ，可以把参数的值转换为相应的字符串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSQR(x) printf(<span class="meta-string">"The square of "</span> #x <span class="meta-string">" is %d.\n"</span>, ((x)*(x)))</span></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">PSQR(<span class="number">2</span>+<span class="number">4</span>);</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">-&gt;The square of <span class="number">2</span>+<span class="number">4</span> is <span class="number">36.</span></span><br></pre></td></tr></table></figure><h4 id="使用-运算符"><a href="#使用-运算符" class="headerlink" title="使用##运算符"></a>使用##运算符</h4><p>##运算符可以把两个语言符号组合成单个语言符号，在程序中，就是生成了一个新的标识符。这种方式的好处在于，利用宏参数，可以创建新的程序变量，可以批量的处理相同类型的逻辑，而不用重复的写多次了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> XNAME(n) x ## n</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINT_XN(n) printf(<span class="meta-string">"x"</span> ## n <span class="meta-string">" = %d.\n"</span>, x ## n);</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// XNAME(1)展开得到的是x1; 同理XNAME(2)就是x2 </span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">XNAME</span><span class="params">(<span class="number">1</span>)</span> </span>= <span class="number">20</span>;</span><br><span class="line">    <span class="comment">// PRINT_XN(1)展开则是printf("x1 = %d\n", x1);</span></span><br><span class="line">    PRINT_XN(<span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">XNAME</span><span class="params">(<span class="number">2</span>)</span> </span>= <span class="number">14</span>;</span><br><span class="line">    PRINT_XN(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用##运算符，还可以用来简化函数的调用。 这样可以简化程序入口逻辑，做到方法分发。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F1(i, a)  fun##i(a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F2(function, i, a) function##i(a)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;<span class="built_in">printf</span>(<span class="string">"fun1(%d) called.\n"</span>, a);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;<span class="built_in">printf</span>(<span class="string">"fun2(%d) called.\n"</span>, a);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tsk2</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;<span class="built_in">printf</span>(<span class="string">"tsk2(%d) called.\n"</span>, a);&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在程序中调用</span></span><br><span class="line">F1(<span class="number">1</span>, <span class="number">5</span>);       <span class="comment">//输出： fun1(5) called.</span></span><br><span class="line">F1(<span class="number">2</span>, <span class="number">6</span>);       <span class="comment">//输出： fun2(6) called.</span></span><br><span class="line">F2(fun, <span class="number">1</span>, <span class="number">5</span>);  <span class="comment">//输出： fun1(5) called.</span></span><br><span class="line">F2(tsk, <span class="number">2</span>, <span class="number">8</span>);  <span class="comment">//输出： tsk2(8) called.</span></span><br></pre></td></tr></table></figure><h3 id="可变宏-使用…和VA-ARGS"><a href="#可变宏-使用…和VA-ARGS" class="headerlink" title="可变宏 使用…和VA_ARGS"></a>可变宏 使用…和<strong>VA_ARGS</strong></h3><p>使用可变宏，可以实现和可变函数相同的功能。在宏定义中参数列表的最后一个参数为省略号(…)。这样在宏实体中使用预定义宏<strong>VA_ARGS</strong>就可以被用来替换省略号所传递的参数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PR(...) printf(__VA_ARGS__)</span></span><br><span class="line"><span class="comment">//根据参数定义输出格式</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PR2(x, ...) printf(<span class="meta-string">"Message"</span>#x<span class="meta-string">":"</span>__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在程序中使用</span></span><br><span class="line">PR(<span class="string">"Howdy"</span>);</span><br><span class="line">PR(<span class="string">"Weight = %d, shipping = $%.2f\n"</span>, <span class="number">340</span>, <span class="number">13.254</span>);<span class="comment">//HowdyWeight = 340, shipping = $13.25</span></span><br><span class="line"><span class="keyword">double</span> x = <span class="number">48</span>;</span><br><span class="line"><span class="keyword">double</span> y = <span class="built_in">sqrt</span>(x);</span><br><span class="line">PR2(<span class="number">1</span>, <span class="string">"x = %g\n"</span>, x); <span class="comment">//Message 1: x= 48</span></span><br><span class="line">PR2(<span class="number">2</span>, <span class="string">"x = %.2f, y = %.4f\n"</span>, <span class="number">48</span>, <span class="number">3.1415925</span>);<span class="comment">//Message 2: x = 48.00, y=7</span></span><br></pre></td></tr></table></figure><h3 id="宏，函数和内联函数"><a href="#宏，函数和内联函数" class="headerlink" title="宏，函数和内联函数"></a>宏，函数和内联函数</h3><p>宏和函数的区别，</p><ol><li>宏会产生内联代码，而函数在程序中只有一份拷贝，函数节省空间，但是运行时，程序的控制必须转移到函数中执行，随后返回调用程序，所以，函数又比内联代码花费更多的时间。c99提供的内联函数可以避免普通函数的这个问题。</li><li>宏的一个优点是不检查其中的变量类型</li><li>宏在某种程度上比常规的函数复杂。所以，一般宏用于简单函数。</li></ol><p>使用宏要注意几点：</p><ol><li>宏的名字不能有空格</li><li>用圆括号括住每一个参数，并括住宏的整体定义</li><li>用大写字母表示宏函数名</li><li>在嵌套循环中使用宏更有助于加速程序运行</li></ol><h2 id="文件包含-include"><a href="#文件包含-include" class="headerlink" title="文件包含 #include"></a>文件包含 #include</h2><p>为什么要包含头文件呢？</p><pre><code>因为这些头文件包含了编译器所需的信息。大部分情况下，头文件中的内容是编译器产生最终代码所需要的信息，而不是加到最终代码里的具体语句。</code></pre><p>一般头文件有哪些内容？</p><pre><code>- 明显常量- 宏函数- 函数声明- 结构模板定义- 类型定义- 可以使用头文件来声明多个文件共享的外部变量。</code></pre><h2 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h2><h3 id="undef指令"><a href="#undef指令" class="headerlink" title="#undef指令"></a>#undef指令</h3><p>undef指令取消定义一个给定的#define，即使开始没有定义，取消也是可以的。</p><h3 id="条件编译指令"><a href="#条件编译指令" class="headerlink" title="条件编译指令"></a>条件编译指令</h3><p>条件编译的一方面可以使程序更容易移植，通过在头文件部分改变几个关键定义，就可以为不同系统设置不同值并包含不同的文件。</p><ol><li>#ifdef, #else 和 #endif指令<br>非常好理解的指令，就和根据编译时的条件接受或者忽略代码块，简单示例：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MAVIS</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"horse.h</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    #define STABLES 5</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#else</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    #include "</span>cow.h<span class="meta-string">"</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    #define STABLES 15</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#endif</span></span></span><br></pre></td></tr></table></figure></li></ol><p>#ifdef #else 非常类似于if-else，而且这些条件结构是可以嵌套的。</p><ol start="2"><li><p>#ifndef指令<br>类似于#ifdef， #ifndef指令也可以和#else， #endif 指令一起使用。这个通常用来定义此前没有定义的常量。经常用在头文件中，防止重复定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MY_SRC_FILE_H_</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> MY_SRC_FILE_H_</span></span><br><span class="line">    <span class="comment">//头文件中的其他内容</span></span><br><span class="line">    ...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li><li><p>#if和#elif指令<br>这就类似于ifhe else if语句了，可以这么使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SYS == 1</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"libmpc.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> SYS == 2</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"vax.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> SYS == 3</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"general.h“</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#endif</span></span></span><br></pre></td></tr></table></figure></li></ol><p>而且#if 结合defined 可以代替 #ifdef 指令的使用， defined是一个预处理器运算符，如果defined的参数已经用#define定义过，则返回1；否则返回0.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> VAX</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(VAX)   <span class="comment">//这两行语句是等价的</span></span></span><br></pre></td></tr></table></figure><h2 id="预定义宏"><a href="#预定义宏" class="headerlink" title="预定义宏"></a>预定义宏</h2><ol><li>C标准制定了一些预定义宏</li></ol><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><strong>DATE</strong></td><td>进行预处理的日期 Mmm dd yyyy</td></tr><tr><td><strong>FILE</strong></td><td>当前源代码文件名的字符串名字</td></tr><tr><td><strong>LINE</strong></td><td>当前源代码文件中的行号</td></tr><tr><td><strong>STDC</strong></td><td>设置为1，则表示该实现遵循C标准</td></tr><tr><td><strong>STDC_HOSTED</strong></td><td>为本机环境设置为1， 否则为0</td></tr><tr><td><strong>STDC_VERSION</strong></td><td>为C99时，设置为199901L</td></tr><tr><td><strong>TIME</strong></td><td>源文件编译时间，格式为hh:mm:ss</td></tr></tbody></table><ol start="2"><li><p>#line 和#error</p><ol><li>指令#line用于重置 <strong>LINE</strong> , <strong>FILE</strong> 报告的行号和文件名。</li><li>指令#error使得预处理器发出一条错误信息，该消息包含指令中的文本。</li></ol></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __STDC_VERSION__ != 199901L</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">error</span> Not C99</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><ol start="3"><li>#pragma</li></ol><p>可以用#pragma将编译器指令置于源代码中，例如可以启用对C9X的支持：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> c9x on  <span class="comment">//c9x代表C99</span></span></span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/wallying/article/details/83104290" target="_blank" rel="noopener">C语言宏中#、##运算符的使用</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;看着C Primer Plus 第16章，复习一下C预处理这一部分知识。 以前学习C语言的时候，对预处理器这一部分很是瞧不起，这有啥呢，无非就是在编译之前做一下字符串替换而已，没有什么技术含量啊。然而事实上是，技术无论好坏高低，能有效且快速解决各种实际问题的才会最终留到最后，C语言的预处理器就属于这种看起来low，但是实际用处非常大的一种功能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;预处理器不仅仅是做了符号替换，还可以根据要求包含其他的文件，可以选择让编译器处理那些代码。虽然预处理器不能理解C，但是扩展的一些预处理器指令还是非常实用。温故而知新，从符号替换开始捋一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://newyearwang.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="c语言" scheme="http://newyearwang.com/tags/c%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu上sudo的坑</title>
    <link href="http://newyearwang.com/2019/09/07/ubuntu%E4%B8%8Asudo%E7%9A%84%E5%9D%91/"/>
    <id>http://newyearwang.com/2019/09/07/ubuntu上sudo的坑/</id>
    <published>2019-09-07T12:20:05.000Z</published>
    <updated>2019-09-07T14:09:58.115Z</updated>
    
    <content type="html"><![CDATA[<p>本来计划在腾讯云上部署一个git服务器的，需要新建一个git账户，并且要配置这个账户sudo权限，然后问题就来了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo adduser git</span><br><span class="line">$ su git</span><br><span class="line">$ <span class="built_in">cd</span></span><br></pre></td></tr></table></figure><p>首先碰到的第一个坑就是 <strong>/etc/sudoers</strong> 这个文件的修改。添加一个新的用户，如果需要通过sudo给一个用户全部的root权限，首先，需要修改这个文件的权限：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo chmod 777 /etc/sudoers</span></span><br></pre></td></tr></table></figure><p>然后，编辑sudoers文件，添加新的账户：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim /etc/sudoers/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在文件末尾添加如下内容（ubuntu16系统中如下格式是没毛病的，</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将user替换为自己的新用户名）</span></span><br><span class="line">user ALL=(ALL:ALL) ALL</span><br></pre></td></tr></table></figure><a id="more"></a><p>上面是我最后修改正确的写法， 如果是在网络上找，会找到好几种写法，有可能是错的。如果sudoers文件内容添加了错误的内容了，就会导致sudo命令没法用了。这个时候就需要重新修改/etc/sudoers文件了，就需要使用<strong>visudo</strong>这个命令来编辑sudoers文件。</p><blockquote><p>visudo会锁住sudoers文件，保存修改到临时文件，然后检查文件格式，确保正确后才会覆盖sudoers文件。必须保证sudoers格式正确，否则sudo将无法运行。<br>警告: /etc/sudoers格式错误会导致sudo不可用。必须使用visudo编辑该文件防止出错。</p></blockquote><p>在sudoers文件编辑错误之后，sudo命令不可用了，这个时候需要使用如下命令来编辑sudoers文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkexec visudo</span><br></pre></td></tr></table></figure><p>在远程ssh来访问服务器时，这个命令有可能正常运报错，因为这个命令只允许本地账户运行，不能是远程ssh连接的用户操作。<a href="https://askubuntu.com/questions/799669/etc-sudoers-file-corrupted-and-i-cant-run-pkexec-visudo-over-ssh" target="_blank" rel="noopener">参考连接2</a>, 大神的操作：</p><ol><li><p>开2个ssh连接到服务器，（一般就是开2个putty的bash窗口）</p></li><li><p>在第一个bash命令行，通过如下命令得到PID值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> $$</span><br></pre></td></tr></table></figure></li><li><p>在第二个bash命令行中，使用如下命令开启授权代理：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkttyagent --process PID(第二步得到的值)</span><br></pre></td></tr></table></figure></li><li><p>然后，在第一个bash命令行中，就可以运行授权命令了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkexec visudo</span><br></pre></td></tr></table></figure></li><li><p>这个时候，第二个命令行中，就会要求输入密码，输入密码之后，第一个命令行中就可以去编辑sudoers文件了，输入合法的内容之后，保存。保证sudoers文件无误。</p></li></ol><p>再一个文件就是前面已经改变了sudoers文件的权限为777了，这时候需要将其权限改回来，不然依然会报错，提示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo ：/etc/sudoers is world writable</span><br><span class="line">sudo : no valid sudoers source found, quitting</span><br><span class="line">sudo : unable to initialize poling plugin</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这是依然可以采用上面的步骤来操作，第二个命令行用于获取授权和输入密码，第一个命令行就可以直接运行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkexec chmod 440 /etc/sudoers</span><br></pre></td></tr></table></figure><p>然后在第二命令行中输入密码， 这是第一个命令行就直接运行结束了，在第一个命令行中输入命令查看下sudoers文件的状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /etc</span><br><span class="line">$ ls -la | grep sudoers</span><br><span class="line">---输出内容</span><br><span class="line">-r--r-----   1 root root     813 Sep  7 20:16 sudoers</span><br><span class="line">drwxr-x---   2 root root    4096 Jun 12 06:36 sudoers.d</span><br><span class="line">-rw-r-----   1 root root   12288 Sep  7 19:53 .sudoers.swo</span><br><span class="line">-rw-------   1 root root   12288 Sep  7 19:51 .sudoers.swp</span><br></pre></td></tr></table></figure><p>这样sudoers文件的状态就改回来了。</p><p>折腾大半天，新账户终于可以正常使用了。生命不息，折腾不止。</p><p>参考：</p><p><a href="https://git-scm.com/book/zh/v2/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-%E9%85%8D%E7%BD%AE%E6%9C%8D%E5%8A%A1%E5%99%A8" target="_blank" rel="noopener">服务器上的-Git-配置服务器</a><br><a href="https://wiki.archlinux.org/index.php/Sudo_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="noopener">Sudo (简体中文)</a><br><a href="https://askubuntu.com/questions/799669/etc-sudoers-file-corrupted-and-i-cant-run-pkexec-visudo-over-ssh" target="_blank" rel="noopener">pkexec visudo不能在ssh远程使用的问题</a><br><a href="https://github.com/NixOS/nixpkgs/issues/18012" target="_blank" rel="noopener">pkexec without a graphical agent fails</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本来计划在腾讯云上部署一个git服务器的，需要新建一个git账户，并且要配置这个账户sudo权限，然后问题就来了。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ sudo adduser git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ su git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ &lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;首先碰到的第一个坑就是 &lt;strong&gt;/etc/sudoers&lt;/strong&gt; 这个文件的修改。添加一个新的用户，如果需要通过sudo给一个用户全部的root权限，首先，需要修改这个文件的权限：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; sudo chmod 777 /etc/sudoers&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;然后，编辑sudoers文件，添加新的账户：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; vim /etc/sudoers/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; 在文件末尾添加如下内容（ubuntu16系统中如下格式是没毛病的，&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; 将user替换为自己的新用户名）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;user ALL=(ALL:ALL) ALL&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://newyearwang.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="http://newyearwang.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Java线程库</title>
    <link href="http://newyearwang.com/2018/02/06/Java%E7%BA%BF%E7%A8%8B%E5%BA%93/"/>
    <id>http://newyearwang.com/2018/02/06/Java线程库/</id>
    <published>2018-02-06T05:16:19.000Z</published>
    <updated>2019-09-07T07:20:28.511Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>线程问题是很重要的,对于理解框架,使用架构,即使自己设计结构,都需要考虑到这一方面的问题, 这是程序正常运行的基石.<br>这也是第一次系统的看这一块的问题, 做的笔记,整理下都有什么内容,同时加深记忆.<br>文章部分内容摘抄自网络上大牛的文章, 经过重新整理编辑, 以便于理解. 如果需要深入理解,文末附有链接地址.</p><h2 id="java5以前的线程同步"><a href="#java5以前的线程同步" class="headerlink" title="java5以前的线程同步"></a>java5以前的线程同步</h2><p>在java5以前,要实现线程同步, 可以使用关键字<strong>synchronized</strong>,然后配合<strong>Object.wait(),Object().notify()</strong>方法,才能实现同步.<br>例如, 这里有一种场景,如何让主线程和子线程同步运行,主线程运行完了,然后子线程运行,然后子线程停住,然后让主线程运行,…</p> <a id="more"></a> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSynchroniezd</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Business business = <span class="keyword">new</span> Business();  <span class="comment">// 事务类实例化</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 子事务在子线程中运行10次</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">                    business.child();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="comment">// 主事务在主线程中运行10次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;        </span><br><span class="line">            business.main();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 子线程和主线程需要处理的事务,都是事务类中的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Business</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 标志位,用于控制当前是主线程运行还是子线程运行,默认子线程运行</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> flagChildRun = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;    <span class="comment">// 本方法表示主线程运行的事物</span></span><br><span class="line">            <span class="keyword">while</span> (flagChildRun) &#123;   <span class="comment">//当标志位表示子线程运行时,等待, 注意这里使用while而不是if</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这一部分,模拟主线程需要处理的事务逻辑</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)&#123;</span><br><span class="line">                System.out.println(<span class="string">"main "</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//事务处理完成, 将标志置为ture,同时调用notify()方法,唤起等待在this上的子线程</span></span><br><span class="line">            flagChildRun = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">this</span>.notify();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">child</span><span class="params">()</span></span>&#123;</span><br><span class="line">             <span class="comment">//当标志位false时,等待</span></span><br><span class="line">            <span class="keyword">while</span> (!flagChildRun) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//模拟事务处理逻辑</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">                System.out.println(<span class="string">"child "</span>+ i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//事务处理完成, 标志位置为false,唤醒主线程</span></span><br><span class="line">            flagChildRun = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">this</span>.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>synchronized关键字的使用是防止多个线程同时访问一个方法或者一个代码块.对象方法上的synchroized拿到的锁是对象本身this,持有同一个锁的synchronized方法是不能同时运行的,抢到锁的先运行,没有抢到锁的阻塞在这里, 等锁被释放之后会再去抢锁,抢到锁之后,才会自动运行.<br>当synchronized加在方法前时,作用其实不是锁住对象中的某个方法，而是锁住对象中所有的加了synchronized的方法.  </p><blockquote><p><em>synchronized关键字最大的问题就在于会导致死锁,死锁其实就是线程在请求一个锁时，该锁一直处于等待状态(如：那个锁已被别的线程获取，且不会释放),于是一直处于等待中状态，就造成了我们的死锁.死锁最典型的例子就是: 两个方法持有两个自己的锁,然后同时运行过程中都尝试去获取对方持有的锁,这时两个方法都必须等待对方释放自己的锁才能继续运行,这样就会一直等待, 这就是死锁状态了.</em></p></blockquote><p>wait()方法调用时,会释放锁, 同时当前运行的线程会暂停在调用对象上面,只有在调用对象上使用notify()方法才能唤醒当前线程的运行. wait(),notify()必须配套使用.</p><p>在sychronized方法或者代码内部,通过wait()等待当前线程, notify() 唤醒其他等待线程, 这种机制,可以实现两个线程的同步.</p><h2 id="Java5之后提供的线程工具"><a href="#Java5之后提供的线程工具" class="headerlink" title="Java5之后提供的线程工具"></a>Java5之后提供的线程工具</h2><h3 id="线程共享变量变量-ThreadLocal"><a href="#线程共享变量变量-ThreadLocal" class="headerlink" title="线程共享变量变量 ThreadLocal"></a>线程共享变量变量 ThreadLocal</h3><p>ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。<br>一言不合上代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                TestBean bean = TestBean.getInstance();  <span class="comment">//子线程中获取线程独享的实例</span></span><br><span class="line">                bean.setAge(<span class="number">10</span>);</span><br><span class="line">                bean.setName(<span class="string">"孙悟空"</span>);  <span class="comment">//设置属性</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);  <span class="comment">//延迟100毫秒等子线程运行完</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在主线程中获取对象实例以及对象实例的属性, 这里应该是获取不到的,输出null</span></span><br><span class="line">        <span class="keyword">int</span> age = TestBean.getInstance().getAge();</span><br><span class="line">        String name = TestBean.getInstance().getName();</span><br><span class="line">        System.out.println(<span class="string">"age : "</span> + age + <span class="string">", name = "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span> </span>&#123;   <span class="comment">//对象实例</span></span><br><span class="line">        <span class="comment">//静态属性ThreadLocal中保存当前对象类型</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;TestBean&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;TestBean&gt;();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> TestBean instance;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">TestBean</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 将对象的实例保存到当前线程局部变量中,</span></span><br><span class="line"><span class="comment">        * 不同的线程通过这个方法获取到的就是不同的对象了</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TestBean <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (threadLocal.get() == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                instance = <span class="keyword">new</span> TestBean();</span><br><span class="line">                threadLocal.set(instance);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> threadLocal.get();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> age;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;<span class="keyword">this</span>.age = age;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> name;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;<span class="keyword">this</span>.name = name;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看了基本介绍，也看了最简单的效果演示之后，我们更应该好好研究下ThreadLocal内部的实现原理。如果给你设计，你会怎么设计？相信大部分人会有这样的想法：</p><blockquote><p><em>每个ThreadLocal类创建一个Map，然后用线程的ID作为Map的key，实例对象作为Map的value，这样就能达到各个线程的值隔离的效果。</em></p></blockquote><p>没错，这是最简单的设计方案，JDK最早期的ThreadLocal就是这样设计的。JDK1.3（不确定是否是1.3）之后ThreadLocal的设计换了一种方式。</p><p>JDK8的ThreadLocal的设计思路, 每个Thread维护一个ThreadLocalMap映射表，这个映射表的key是ThreadLocal实例本身，value是真正需要存储的Object。</p><p>这个方案刚好与我们开始说的简单的设计方案相反。查阅了一下资料，这样设计的主要有以下几点优势：</p><ul><li>这样设计之后每个Map的Entry数量变小了：之前是Thread的数量，现在是ThreadLocal的数量，能提高性能</li><li>当Thread销毁之后对应的ThreadLocalMap也就随之销毁了,就不同担心随着线程增多,会出现啊ThreadLocal中存储的数据不能销毁而导致内存泄露了</li></ul><p>ThreadLocal在spring的事务管理，包括Hibernate的session管理等都有出现，在web开发中，有时会用来管理用户会话 HttpSession，web交互中这种典型的一请求一线程的场景似乎比较适合使用ThreadLocal，但是需要特别注意的是，由于此时session与线程关联，而tomcat这些web服务器多会采用线程池机制，也就是说线程是可复用的，所以在每一次进入的时候都需要重新进行set，或者在结束时及时remove。</p><h3 id="线程池工具和线程池-Executors-ExecutorService-ThreadPoolExecutor"><a href="#线程池工具和线程池-Executors-ExecutorService-ThreadPoolExecutor" class="headerlink" title="线程池工具和线程池 Executors, ExecutorService, ThreadPoolExecutor"></a>线程池工具和线程池 Executors, ExecutorService, ThreadPoolExecutor</h3><p><img src="https://eucwang.github.io/img/threadpool_uml.png" alt="类图"></p><p><strong>Executor</strong>是一个顶层接口，在它里面只声明了一个方法<strong>execute(Runnable)</strong>，返回值为void，参数为Runnable类型，从字面意思可以理解，就是用来执行任务的.</p><p><strong>ExecutorService</strong>接口继承了Executor接口，并声明了一些方法：submit()、invokeAll()、invokeAny()以及shutDown()等.</p><p>抽象类<strong>AbstractExecutorService</strong>实现了<strong>ExecutorService</strong>接口，基本实现了ExecutorService中声明的所有方法</p><p>然后<strong>ThreadPoolExecutor</strong>继承了类<strong>AbstractExecutorService</strong>, <strong>ThreadPoolExecutor</strong>是线程池的最主要的类, 重点的几个重要方法如下:</p><ul><li>execute()</li><li>submit()</li><li>shutdown()</li><li>shutdownNow()</li></ul><p>方法的解释说明在UML图上已经说明过了,这里就不重复.</p><p>ThreadPoolExecutor有属性为<strong>runState</strong>, 表示线程池的状态，runState有4种状态. 它是一个<strong>volatile</strong>变量, 用来保证线程之间的可见性.</p><pre><code>volatile int runState;static final int RUNNING    = 0;static final int SHUTDOWN   = 1;static final int STOP       = 2;static final int TERMINATED = 3;</code></pre><ul><li>当创建线程池后，初始时，线程池处于RUNNING状态；</li><li>如果调用了shutdown()方法，则线程池处于SHUTDOWN状态，此时线程池不能够接受新的任务，它会等待所有任务3. 执行完毕；</li><li>如果调用了shutdownNow()方法，则线程池处于STOP状态，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务；</li><li>当线程池处于SHUTDOWN或STOP状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后，线程池被设置为TERMINATED状态。</li></ul><p>线程池的使用还是比较简单的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestExecutors</span> </span>&#123;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ExecutorService threadPool = Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"time "</span> + <span class="keyword">new</span> Date(System.currentTimeMillis()));</span><br><span class="line">Future&lt;String&gt; future = threadPool.submit(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"><span class="keyword">return</span> Thread.currentThread().getName() + <span class="keyword">new</span> Random().nextInt();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"time "</span> + <span class="keyword">new</span> Date(System.currentTimeMillis()) + <span class="string">",  "</span> + future.get());</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">threadPool.shutdown();</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="并发编程中的三个概念"><a href="#并发编程中的三个概念" class="headerlink" title="并发编程中的三个概念"></a>并发编程中的三个概念</h2><ol><li><strong>原子性</strong><br><em>即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行</em></li><li><strong>可见性</strong><br> <em>当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</em></li><li><strong>有序性</strong><br><em>即程序执行的顺序按照代码的先后顺序执行。处理器由于会指令重排序,会打乱最终指令的顺序.虽然会保证程序最终执行结果.</em></li></ol><p><strong>缓存一致性问题</strong>也就是可见性问题.</p><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>Java内存模型虽然会屏蔽不同硬件平台和操作系统差异,但是对于并发支持只是部分的:</p><ol><li>只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是保证是原子操作。</li><li>volatile关键字来保证可见性,当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。synchronized和Lock也能够保证可见性</li><li>重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。volatile关键字能保证一定的“有序性”, 可以通过synchronized和Lock来保证有序性.</li></ol><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><h3 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h3><p>这里很有必要说说volatile关键字.volatile关键字一般情况下我们都不会使用到, 比较陌生.字面意思: 不稳定的,反复无常的.</p><p>当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中,那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。</p><p>在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的）。<br>比如要执行:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = i+<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>同时有2个线程执行这段代码，假如初始时i的值为0，那么我们希望两个线程执行完之后i的值变为2。<strong><em>但是事实会是这样吗？</em></strong></p><p>可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。</p><p><img src="https://eucwang.github.io/img/duplicate_cache_uml.png" alt="a"></p><p>最终结果i的值是1，而不是2。这就是著名的缓存一致性问题。</p><h3 id="volatile关键字的使用"><a href="#volatile关键字的使用" class="headerlink" title="volatile关键字的使用"></a>volatile关键字的使用</h3><p>volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：</p><ul><li>对变量的写操作不依赖于当前值</li><li>该变量没有包含在具有其他变量的不变式中</li></ul><p>实际上，这些条件表明，可以被写入volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。事实上，我的理解就是上面的2个条件需要保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。</p><p>1.状态标记量的场景</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span>(!flag)&#123;</span><br><span class="line">    <span class="comment">//doSomething();</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    flag = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.单例时的双检查</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="同步锁-Lock-Condition-ReadWriteLock"><a href="#同步锁-Lock-Condition-ReadWriteLock" class="headerlink" title="同步锁 Lock, Condition, ReadWriteLock"></a>同步锁 Lock, Condition, ReadWriteLock</h2><h3 id="用Lock和Condition来实现本文开始的synchronized的通知-唤醒模型"><a href="#用Lock和Condition来实现本文开始的synchronized的通知-唤醒模型" class="headerlink" title="用Lock和Condition来实现本文开始的synchronized的通知-唤醒模型"></a>用Lock和Condition来实现本文开始的synchronized的通知-唤醒模型</h3><p>一个例子如下， 代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Business business = <span class="keyword">new</span> Business();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;<span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span>; i++)&#123;</span><br><span class="line">                    business.stub();  <span class="comment">//子事务运行6次在子线程,</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">            business.main();  <span class="comment">//主事务运行5次在主线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Business</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();   <span class="comment">//生成锁</span></span><br><span class="line">        <span class="keyword">private</span> Condition condition = lock.newCondition();  <span class="comment">//获得锁上面的condition对象</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isStubRun = <span class="keyword">true</span>;  <span class="comment">//标志位,用于控制事务切换</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">            lock.lock();                <span class="comment">//如下代码直到unloc()k为止,都被加锁,防止多线程执行</span></span><br><span class="line">            <span class="keyword">while</span> (isStubRun) &#123;        <span class="comment">//标志位为true时,当前线程等待,直到被唤醒,while防止假唤醒</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"isStubRun true in main so condition wait...."</span>);</span><br><span class="line">                    condition.await();   </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;   <span class="comment">//模拟事务运行</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    System.out.println(<span class="string">"main run "</span> + Thread.currentThread().getName() + <span class="string">", index = "</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                isStubRun = <span class="keyword">true</span>;     <span class="comment">//标志位置为true</span></span><br><span class="line">                condition.signal();  <span class="comment">//condition发出信号,激活在这个锁上等待的其他线程</span></span><br><span class="line">                System.out.println(<span class="string">"release condition in main ......"</span>);</span><br><span class="line">                lock.unlock();  <span class="comment">//释放锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stub</span><span class="params">()</span></span>&#123;</span><br><span class="line">            lock.lock();              <span class="comment">//如下代码知道unlock为止,都被加锁,防止多线程执行</span></span><br><span class="line">            <span class="keyword">while</span> (!isStubRun) &#123;      <span class="comment">//标志位为false时, 当期线程等待,直到被唤醒,while防止假唤醒</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"isStubRun false in stub so condition wait...."</span>);</span><br><span class="line">                    condition.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span>&#123;       <span class="comment">//模拟事务运行</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">                    System.out.println(<span class="string">"stub run "</span> + Thread.currentThread().getName() + <span class="string">", index = "</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                isStubRun = <span class="keyword">false</span>;    <span class="comment">//标志位置为false</span></span><br><span class="line">                condition.signal();   <span class="comment">//condition发出信号,激活在这个锁上等待的其他线程</span></span><br><span class="line">                System.out.println(<span class="string">"release condition in main ......"</span>);</span><br><span class="line">                lock.unlock();        <span class="comment">//释放锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<strong>condition.await(), condition.signal()</strong>方法调用必须在<strong>lock.lock()和lock.unlock()</strong>的代码块中间.<br><strong>ReentranctLock.newCondition()</strong>方法, 返回用来与此 Lock 实例一起使用的Condition 实例。一个ReentrantLock可以有多个Condition实例，所以更有扩展性。</p><p>Lock,ReentrantLock,Condition, 还有ReentrantReadWriteLock这几个接口和类之间的关系见下图:</p><p><img src="https://eucwang.github.io/img/uml_lock.png" alt></p><h3 id="实现生产者消费者的模型"><a href="#实现生产者消费者的模型" class="headerlink" title="实现生产者消费者的模型"></a>实现生产者消费者的模型</h3><p>用Lock, Condition来实现生产者消费者的模型也是比较容易理解的, 这也是一个Lock多个Condition的一个很好的示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QUEUE_LENGTH = <span class="number">100</span>; <span class="comment">// 队列数组的大小    </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] queue = <span class="keyword">new</span> <span class="keyword">int</span>[QUEUE_LENGTH]; <span class="comment">// 队列数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> indicatorAddIndex = <span class="number">0</span>;     <span class="comment">// 需要添加时,指向的位置索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> indicatorRemoveIndex = <span class="number">0</span>;  <span class="comment">// 需要移除时, 指向的位置索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> countOfItems = <span class="number">0</span>;         <span class="comment">// 当前缓存队列中的已经有的数据的数量</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition inCondition;   <span class="comment">//添加的锁条件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition outCondition;  <span class="comment">//移除的锁条件</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">QueueCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        inCondition = lock.newCondition();</span><br><span class="line">        outCondition = lock.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> QueueCache instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> QueueCache <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;instance = <span class="keyword">new</span> QueueCache();&#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向缓存中添加</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> item)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (countOfItems == QUEUE_LENGTH) &#123;    <span class="comment">//根据队列中的数量来判断是否可以添加</span></span><br><span class="line">                System.out.println(<span class="string">"满了, 不能添加,等待"</span>);</span><br><span class="line">                inCondition.await();                  <span class="comment">// 满了, 不能添加,inCodition等待</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"将"</span> + item + <span class="string">"加入到 index = "</span> + indicatorAddIndex + <span class="string">"的位置"</span>);</span><br><span class="line">            queue[indicatorAddIndex] = item;</span><br><span class="line">            <span class="keyword">if</span> (indicatorAddIndex == QUEUE_LENGTH - <span class="number">1</span>) &#123; <span class="comment">//指向最后一个元素了</span></span><br><span class="line">                indicatorAddIndex = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                indicatorAddIndex ++;                  <span class="comment">//移动指针指向下一个位置</span></span><br><span class="line">            &#125;</span><br><span class="line">            countOfItems++;                            <span class="comment">//当前队列中的数量+1</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"添加完成"</span>);</span><br><span class="line">            outCondition.signal();                     <span class="comment">//向outCondition发送信号,通知其唤醒</span></span><br><span class="line">            lock.unlock();         </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从缓存队列中移除</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">int</span> retVal = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (countOfItems == <span class="number">0</span>) &#123;        <span class="comment">//根据队列中的数量来判断是否可以移除</span></span><br><span class="line">                System.out.println(<span class="string">"队列空了, 不能再移除了"</span>);</span><br><span class="line">                outCondition.await();          <span class="comment">//队列空了, 不能再移除了,outCondition等待,</span></span><br><span class="line">            &#125;                          </span><br><span class="line">            retVal = queue[indicatorRemoveIndex];</span><br><span class="line">            System.out.println(<span class="string">"将"</span> + retVal + <span class="string">"从位置index = "</span> + indicatorRemoveIndex + <span class="string">"移除"</span>);</span><br><span class="line">            <span class="keyword">if</span> (indicatorRemoveIndex == QUEUE_LENGTH - <span class="number">1</span>) &#123;</span><br><span class="line">                indicatorRemoveIndex = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                indicatorRemoveIndex ++;       <span class="comment">//移动移除的指针</span></span><br><span class="line">            &#125;</span><br><span class="line">            countOfItems--;                    <span class="comment">//当前队列中的数据量-1</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(getSpace() +<span class="string">"移除完成"</span>);</span><br><span class="line">            inCondition.signal();               <span class="comment">//想inCondition发送信号,通知其唤醒</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读写锁ReentrantReadWriteLock"><a href="#读写锁ReentrantReadWriteLock" class="headerlink" title="读写锁ReentrantReadWriteLock"></a>读写锁ReentrantReadWriteLock</h3><p>所谓<strong>读写锁</strong>，是对访问资源共享锁和排斥锁，一般的重入性语义为:</p><ul><li>如果对资源加了写锁，其他线程无法再获得写锁与读锁，但是持有写锁的线程，可以对资源加读锁（锁降级）；</li><li>如果一个线程对资源加了读锁，其他线程可以继续加读锁。</li></ul><p>ReentrantReadWriterLock通过两个内部类实现Lock接口，分别是ReadLock,WriterLock类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockTestBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> data = <span class="number">0</span>;    <span class="comment">//需要被锁的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ReadWriteLock rwLock = <span class="keyword">new</span> ReentrantReadWriteLock();  <span class="comment">//读写锁</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>&#123;  <span class="comment">//读取数据</span></span><br><span class="line">        rwLock.readLock().lock();  <span class="comment">//读锁加锁,</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//System.out.println(Thread.currentThread().getName() + " try to get data");</span></span><br><span class="line">            <span class="comment">//Thread.sleep(new Random().nextInt(5000));</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;ex.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.readLock().unlock();  <span class="comment">//释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//System.out.println(Thread.currentThread().getName() + " get data is " + data);</span></span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> newData)</span></span>&#123;</span><br><span class="line">        rwLock.writeLock().lock();  <span class="comment">//写锁加锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" try to write data"</span>);</span><br><span class="line">            <span class="comment">//Thread.sleep(new Random().nextInt(5000));</span></span><br><span class="line">            data = newData;  <span class="comment">//设置数据</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" have write data is "</span> + data);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;ex.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他同步工具"><a href="#其他同步工具" class="headerlink" title="其他同步工具"></a>其他同步工具</h2><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>Semaphore是一种基于计数的信号量。<br>它可以设定一个阈值，基于此，多个线程竞争获取许可信号，做完自己的申请后归还，超过阈值后，线程申请许可信号将会被阻塞。<br>Semaphore可以用来构建一些对象池，资源池之类的，比如数据库连接池，我们也可以创建计数为1的Semaphore，将其作为一种类似互斥锁的机制，这也叫二元信号量，表示两种互斥状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSemaphore</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService threadPool = Executors.newCachedThreadPool();</span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);  <span class="comment">//创建一个计数阈值为5的信号量对象,只能5个线程同时访问 </span></span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;               <span class="comment">//生成10个线程</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">            Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        semaphore.acquire();      <span class="comment">// 申请许可  </span></span><br><span class="line">                        <span class="keyword">try</span>&#123;</span><br><span class="line">                            <span class="comment">//执行业务逻辑</span></span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">" index : "</span> + index + <span class="string">", permits"</span> + </span><br><span class="line">                            semaphore.availablePermits());</span><br><span class="line">                        &#125;<span class="keyword">catch</span>(Exception e)&#123;e.printStackTrace();&#125;</span><br><span class="line">                        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                            semaphore.release(); <span class="comment">//释放许可</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            threadPool.execute(runnable);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>CyclicBarrier是一个同步工具类，它允许一组线程在到达某个栅栏点(common barrier point)互相等待，发生阻塞，直到最后一个线程到达栅栏点，栅栏才会打开，处于阻塞状态的线程恢复继续执行.它非常适用于一组线程之间必需互相等待的情况。<br>CyclicBarrier字面理解是循环的栅栏，之所以称之为循环的是因为在等待线程释放后，该栅栏还可以复用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCyclicBarrier</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService threadPool = Executors.newCachedThreadPool(); <span class="comment">//线程池</span></span><br><span class="line"></span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">3</span>);  <span class="comment">//3个等待线程的循环栅栏</span></span><br><span class="line"></span><br><span class="line">        Random random = <span class="keyword">new</span> Random();  <span class="comment">//随机数生成器</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;     <span class="comment">//循环创建3个线程</span></span><br><span class="line">            Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(random.nextInt(<span class="number">20</span>) * <span class="number">100</span>);  <span class="comment">//休眠随机时间</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.out.println(QueueCache.getStrDate() + <span class="string">", "</span> +</span><br><span class="line">                            Thread.currentThread().getName() + <span class="string">" 准备好了"</span></span><br><span class="line">                            + <span class="string">", 当前等待数: "</span> + cyclicBarrier.getNumberWaiting());</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//等待其他所有线程,如果其他线程都执行到了await()方法这里,然后所有线程并发一起执行</span></span><br><span class="line">                        cyclicBarrier.await();  </span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;e.printStackTrace();&#125;</span><br><span class="line"></span><br><span class="line">                    System.out.println(QueueCache.getStrDate() +  <span class="string">", "</span> +</span><br><span class="line">                            Thread.currentThread().getName() + <span class="string">"开始执行"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            threadPool.execute(runnable); <span class="comment">//线程执行</span></span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();  <span class="comment">//关闭线程池</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。也就是说，<strong>CountDownLatch</strong>控制某个或者多个线程，让它们等待多个线程完成某项任务后，再启动。<strong>CountDownLatch</strong>主要是用来同步多个任务的执行，区别于其他的synchronized关键字，锁，信号量是用来同步共享资源的。</p><p><strong>CountDownLatch</strong>内部维护一个计数器，计数器的值为待完成的任务数Ｎ，需要等待这Ｎ个任务完成的线程调用<strong>CountDownLatch</strong>的<strong>await()</strong>方法使自己进入休眠等待状态。当某一个任务线程完成某一个任务后调用<strong>CountDownLatch</strong>的<strong>countDown()</strong>方法来表示自己的任务已完成，此时CountDownLatch的计数器值减１，当所有的任务完成式，计数器的值为０。当计数器值为0时，<strong>CountDownLatch</strong>将唤醒所有因<strong>await()</strong>方法进入休眠的线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCountDownLatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService threadPool = Executors.newCachedThreadPool(); <span class="comment">//线程池</span></span><br><span class="line">        <span class="comment">//创建2个倒计时闭锁</span></span><br><span class="line">        CountDownLatch downLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>); <span class="comment">//初始计数器为1</span></span><br><span class="line">        CountDownLatch overLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">3</span>); <span class="comment">//初始计数器为3</span></span><br><span class="line">        <span class="comment">//随机数生成器</span></span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="comment">//用于打印时间显示时分秒毫秒</span></span><br><span class="line">        SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss:SSS"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;    <span class="comment">//循环创建3个线程并添加到线程池中运行</span></span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(dateFormat.format(<span class="keyword">new</span> Date()) + <span class="string">": "</span> + Thread.currentThread().getName() + <span class="string">" 已经准备就绪."</span>);</span><br><span class="line">                    <span class="comment">// 等待downLatch.countDown(),如果计数到0,则本线程继续执行</span></span><br><span class="line">                    downLatch.await();</span><br><span class="line">                    System.out.println(dateFormat.format(<span class="keyword">new</span> Date()) + <span class="string">": 开始跑"</span>);</span><br><span class="line">                    Thread.sleep(random.nextInt(<span class="number">3000</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"到达终点..."</span>);</span><br><span class="line">                <span class="comment">//overLatch的计数器为3,倒计数, 当3个线程都调用完这个方法,overLatch的计数才为0,然后overLatch.await()处代码才能继续向下运行</span></span><br><span class="line">                overLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        threadPool.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(random.nextInt(<span class="number">5000</span>));</span><br><span class="line">                System.out.println(QueueCache.getStrDate() + <span class="string">": "</span> + Thread.currentThread().getName() + <span class="string">"倒计时结束."</span>);</span><br><span class="line">                downLatch.countDown();       <span class="comment">//downLatch计数器为1, 执行一次countDown(),则计数器为0,则调用downLatch.await()的地方继续执行.</span></span><br><span class="line">                overLatch.await();           <span class="comment">//overLatch等待在overLatch上的计数到0,</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"活动结束"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadPool.shutdown(); <span class="comment">//关闭线程池</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h3><p><strong>Exchanger</strong>它可以在两个线程之间传输数据.<br><strong>Exchanger</strong>中的<strong>exchange(V x)</strong>方法被调用后等待另一个线程到达交换点（如果当前线程没有被中断），然后将已知的对象传给它，返回接收的对象。如果另外一个线程已经在交换点等待，那么恢复线程继续执行, 并且接收通过传递的对象.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestExchanger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService threadPool = Executors.newCachedThreadPool();</span><br><span class="line">        Exchanger&lt;Integer&gt; exchanger = <span class="keyword">new</span> Exchanger&lt;&gt;();  <span class="comment">//线程数据交换类</span></span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss:SSS"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++) &#123;         <span class="comment">//循环创建2个线程,并添加到线程池中运行</span></span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(dateFormat.format(<span class="keyword">new</span> Date()) + <span class="string">": "</span> + Thread.currentThread().getName() + <span class="string">"准备好了"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(random.nextInt(<span class="number">5000</span>));  <span class="comment">//休眠随机时间</span></span><br><span class="line">                    <span class="keyword">int</span> value = random.nextInt(<span class="number">100</span>);     <span class="comment">//获得一个数值</span></span><br><span class="line">                    System.out.println(dateFormat.format(<span class="keyword">new</span> Date()) + <span class="string">": "</span> + Thread.currentThread().getName() + <span class="string">" 传递给对方线程的数据: "</span> + value);</span><br><span class="line">                    <span class="comment">//将数据传递给对方线程,同时接受从对方线程传递的数据, 任意一个线程如果首先运行到这里,则阻塞等待对方线程运行到这里, 再交换数据</span></span><br><span class="line">                    Integer exchangeVal = exchanger.exchange(value); </span><br><span class="line">                    System.out.println(dateFormat.format(<span class="keyword">new</span> Date()) + <span class="string">": "</span> + Thread.currentThread().getName() + <span class="string">" 从对方线程获得的数据: "</span> + exchangeVal);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="阻塞队列-BlockingQueue"><a href="#阻塞队列-BlockingQueue" class="headerlink" title="阻塞队列 BlockingQueue"></a>阻塞队列 BlockingQueue</h3><p>自从Java 1.5之后，在java.util.concurrent包下提供了若干个阻塞队列，主要有以下几个：</p><ul><li>ArrayBlockingQueue：基于数组实现的一个阻塞队列，在创建        ArrayBlockingQueue对象时必须制定容量大小。并且可以指定公平性与非公平性，默认情况下为非公平的，即不保证等待时间最长的队列最优先能够访问队列。</li><li>LinkedBlockingQueue：基于链表实现的一个阻塞队列，在创建LinkedBlockingQueue对象时如果不指定容量大小，则默认大小为Integer.MAX_VALUE。</li><li>PriorityBlockingQueue：以上2种队列都是先进先出队列，而PriorityBlockingQueue却不是，它会按照元素的优先级对元素进行排序，按照优先级顺序出队，每次出队的元素都是优先级最高的元素。注意，此阻塞队列为无界阻塞队列，即容量没有上限（通过源码就可以知道，它没有容器满的信号标志），前面2种都是有界队列。</li></ul><p><img src="https://eucwang.github.io/img/uml_block_queue.png" alt></p><h3 id="用ArrayBlockingQueue实现生产者消费者模型"><a href="#用ArrayBlockingQueue实现生产者消费者模型" class="headerlink" title="用ArrayBlockingQueue实现生产者消费者模型"></a>用ArrayBlockingQueue实现生产者消费者模型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBlockingQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QUEUE_SIZE = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        TestBlockingQueue test = <span class="keyword">new</span> TestBlockingQueue();</span><br><span class="line">        ArrayBlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Integer&gt;(QUEUE_SIZE);</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="comment">//消费线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(random.nextInt(<span class="number">1000</span>));</span><br><span class="line">                    System.out.println(<span class="string">"预备从队列中取走一个元素."</span>);</span><br><span class="line">                    queue.take();   </span><br><span class="line">                    System.out.println(<span class="string">"从队列取走一个元素，队列剩余"</span>+queue.size()+<span class="string">"个元素"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="comment">//生成线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(random.nextInt(<span class="number">2000</span>));</span><br><span class="line">                    System.out.println(<span class="string">"\t\t\t\t\t\t\t预备想队列中插入一个元素"</span>);</span><br><span class="line">                    queue.put(<span class="number">1</span>);</span><br><span class="line">                    System.out.println(<span class="string">"\t\t\t\t\t\t\t向队列取中插入一个元素完成，队列剩余空间："</span>+(QUEUE_SIZE-queue.size()));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有好几组取数据和放数据的方法, 需要做一下区分</p><table><thead><tr><th>是否阻塞</th><th>方法</th><th>作用</th><th>区别</th></tr></thead><tbody><tr><td>非阻塞</td><td>add(E)</td><td>添加元素到队尾</td><td>不能添加时会抛出异常</td></tr><tr><td>非阻塞</td><td>offer(E)</td><td>添加元素到队尾</td><td>添加成功返回true,不能添加时会直接返回false</td></tr><tr><td>阻塞</td><td>put(E)</td><td>添加元素到队尾</td><td>不能添加时会阻塞</td></tr><tr><td>阻塞</td><td>offer(E e, long timeout, TimeUnit unit)</td><td>向队尾添加元素,若队满则等待指定时间</td><td>成功返回true,否则false</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>非阻塞</td><td>remove()</td><td>从队首移除并返回元素</td><td>移除成功返回true,否则直接抛出异常</td></tr><tr><td>非阻塞</td><td>poll()</td><td>从队首移除并返回元素</td><td>成功则返回队首元素,否则返回null</td></tr><tr><td>非阻塞</td><td>peek()</td><td>获取队首元素</td><td>成功则返回队首元素, 否则返回null</td></tr><tr><td>阻塞</td><td>take()</td><td>从队首取出元素</td><td>不能取出元素时会阻塞</td></tr><tr><td>阻塞</td><td>poll(long timeout, TimeUnit unit)</td><td>从队首移除并返回元素,若队列空则等待指定时间</td><td>成功则返回队首元素,否则返回null</td></tr></tbody></table><h2 id="集合的同步问题-ConcurrentHashMap"><a href="#集合的同步问题-ConcurrentHashMap" class="headerlink" title="集合的同步问题 ConcurrentHashMap"></a>集合的同步问题 ConcurrentHashMap</h2><p><strong>ConcurrentHashMap</strong>是一个经常被使用的数据结构，相比于<strong>Hashtable</strong>以及<strong>Collections.synchronizedMap()</strong>，<strong>ConcurrentHashMap</strong>在线程安全的基础上提供了更好的写并发能力.<strong>HashTable</strong>是一个线程安全的类，它使用<strong>synchronized</strong>来锁住整张Hash表来实现线程安全，即每次锁住整张表让线程独占。  <strong>ConcurrentHashMap</strong>允许多个修改操作并发进行，其关键在于使用了锁分离技术。它使用了多个锁来控制对hash表的不同部分进行的修改。    <strong>ConcurrentHashMap</strong>内部使用段(<strong>Segment</strong>)来表示这些不同的部分，每个段其实就是一个小的<strong>Hashtable</strong>，它们有自己的锁。只要多个修改操作发生在不同的段上，它们就可以并发进行。</p><p>参考:<br><a href="https://www.cnblogs.com/beiyetengqing/p/6213437.html" target="_blank" rel="noopener">Java synchronized 详解</a><br><a href="http://blog.csdn.net/silk_bar/article/details/51051679" target="_blank" rel="noopener">Java多线程之synchronized及死锁编写</a><br><a href="https://www.cnblogs.com/ysw-go/p/5944837.html" target="_blank" rel="noopener">深入剖析ThreadLocal</a><br><a href="https://www.cnblogs.com/chengxiao/p/6152824.html" target="_blank" rel="noopener">谈谈Java中的ThreadLocal</a><br><a href="http://www.cnblogs.com/dolphin0520/p/3932921.html" target="_blank" rel="noopener">Java并发编程：线程池的使用</a><br><a href="http://www.importnew.com/18126.html" target="_blank" rel="noopener">Java并发编程：volatile关键字解析</a><br><a href="http://blog.csdn.net/prestigeding/article/details/53286756" target="_blank" rel="noopener">java并发锁ReentrantReadWriteLock读写锁源码分析</a><br><a href="http://blog.csdn.net/lipeng_bigdata/article/details/52165426" target="_blank" rel="noopener">Java并发之Semaphore详解</a><br><a href="http://www.cnblogs.com/ysw-go/p/5954491.html" target="_blank" rel="noopener">Java并发编程：阻塞队列</a><br><a href="https://my.oschina.net/hosee/blog/639352" target="_blank" rel="noopener">ConcurrentHashMap原理分析</a><br><a href="https://my.oschina.net/hosee/blog/675884" target="_blank" rel="noopener">ConcurrentHashMap总结</a>  </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;线程问题是很重要的,对于理解框架,使用架构,即使自己设计结构,都需要考虑到这一方面的问题, 这是程序正常运行的基石.&lt;br&gt;这也是第一次系统的看这一块的问题, 做的笔记,整理下都有什么内容,同时加深记忆.&lt;br&gt;文章部分内容摘抄自网络上大牛的文章, 经过重新整理编辑, 以便于理解. 如果需要深入理解,文末附有链接地址.&lt;/p&gt;
&lt;h2 id=&quot;java5以前的线程同步&quot;&gt;&lt;a href=&quot;#java5以前的线程同步&quot; class=&quot;headerlink&quot; title=&quot;java5以前的线程同步&quot;&gt;&lt;/a&gt;java5以前的线程同步&lt;/h2&gt;&lt;p&gt;在java5以前,要实现线程同步, 可以使用关键字&lt;strong&gt;synchronized&lt;/strong&gt;,然后配合&lt;strong&gt;Object.wait(),Object().notify()&lt;/strong&gt;方法,才能实现同步.&lt;br&gt;例如, 这里有一种场景,如何让主线程和子线程同步运行,主线程运行完了,然后子线程运行,然后子线程停住,然后让主线程运行,…&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://newyearwang.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="http://newyearwang.com/tags/java/"/>
    
      <category term="多线程" scheme="http://newyearwang.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>一个昨天晚上的梦</title>
    <link href="http://newyearwang.com/2018/02/02/%E4%B8%80%E4%B8%AA%E6%98%A8%E5%A4%A9%E6%99%9A%E4%B8%8A%E7%9A%84%E6%A2%A6/"/>
    <id>http://newyearwang.com/2018/02/02/一个昨天晚上的梦/</id>
    <published>2018-02-02T04:56:50.000Z</published>
    <updated>2019-09-07T07:20:20.601Z</updated>
    
    <content type="html"><![CDATA[<p>昨天晚上睡的比较晚</p><p>睡着之后</p><p>一梦回到大学</p><p>灰蒙蒙的景色</p><p>恍惚间去一个小窗口不知道是做什么</p><p>好像是缴费</p><p>然后是让我等通知还是怎么的</p><p>我就到一个小桌子旁坐下</p><a id="more"></a><p>很无助的</p><p>战战兢兢的</p><p>依稀是年轻无知的农村出来的样子</p><p>还是老样子</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天晚上睡的比较晚&lt;/p&gt;
&lt;p&gt;睡着之后&lt;/p&gt;
&lt;p&gt;一梦回到大学&lt;/p&gt;
&lt;p&gt;灰蒙蒙的景色&lt;/p&gt;
&lt;p&gt;恍惚间去一个小窗口不知道是做什么&lt;/p&gt;
&lt;p&gt;好像是缴费&lt;/p&gt;
&lt;p&gt;然后是让我等通知还是怎么的&lt;/p&gt;
&lt;p&gt;我就到一个小桌子旁坐下&lt;/p&gt;
    
    </summary>
    
    
      <category term="生活" scheme="http://newyearwang.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="闲文" scheme="http://newyearwang.com/tags/%E9%97%B2%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>2017年终总结</title>
    <link href="http://newyearwang.com/2018/02/01/2017%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>http://newyearwang.com/2018/02/01/2017年终总结/</id>
    <published>2018-02-01T04:52:22.000Z</published>
    <updated>2019-09-07T07:20:14.353Z</updated>
    
    <content type="html"><![CDATA[<p>要年终总结了, 翻出来旧的blog, 擦擦灰,看看以前写了写啥.总结下去年一年做了那些工作,学习了那些内容,生活里有那些改变.想想家人,想想自己.同时把新的blog迁移到这里,快过年了,也是新年新气象.祝愿2018年在逆境中一切顺利.</p><p>2017年工作和学习都比较焦虑,去年开始接触公司的后台开发了的, 今年刚开始,想着更进一步学后台的 然而公司人事变动,这个想法也不了了之了.</p><p>上半年公司老板拍脑袋决定要重构系统,其实是想用微服务来重写系统,然后CTO不干了,5月份离职,然后就是裁人招人裁人,新系统还部分外包,旧系统继续运行,继续接需求,一团糟.结果到年底,钱烧了, 新系统也出不来,然后拉投资, 投资也没拉进来.又开始想各种办法省钱, 折腾的不行.</p><p>我的工作依然是android端app.</p><p>夏天时, 给我任务独立开发了2个小app.然后还有一个蓝牙的SDK包.</p><p>十一没有放假, 紧急接了一个演示app,4个人android/ios两端大概1个来星期完成.从公司强要了加班费,还不愿意给.</p><a id="more"></a><p>然后到11月份在后台接口都差一大截的情况下,勉强完成了新版app.</p><p>2018年工作上还需要在公司坚持一段时间,预估半年,手上没钱总是比较焦虑,换工作了一家老小没有收入也是让人很着急的事情.</p><p>android端学习使用新的技术: MVVM/databinding, Rxjava, 根据google todo sample 的结构简化成一个自己使用的MVVM架构,用到今年新做的APP上, 勉强够用.dagger是从入门到放弃,理解起来很费劲.所以也就没有使用.</p><p>12月底1月初,学习了下python,看了两本书 《简明Python教程》和《Python编程-从入门到实践》, 第二本看了一大半,捡我需要的看了下,然后接着看了《机器学习实战》,看了大概2/3,实在看不下去了,数学基础太薄弱了, 看支持向量机都看了差不多一个星期都没看懂.这个不应该放弃,但是暂时需要放一下,有一点受打击了.</p><p>接下来2018年的学习计划应该是这样的:</p><ul><li><p>首先,需要巩固下java基础,数据结构和算法,设计模式, 不管是android还是Javaee, 这个都是我的基础, 温故而知新.</p></li><li><p>其次,对应android,目前需要拓展知识面,有几个方向,这几个方向只能一个一个去实现了.</p><ul><li>react-native</li><li>opengl/视频/音频</li><li>kotlin</li></ul></li><li><p>然后就是javaee后台的知识,既然已经学习过,而且对应工作有实实在在的好处,就应该继续深入学习, 2018年需要完成一个完整的学习项目</p></li><li><p>然后就是pyhton的数据分析,书已经买了,躺在那里等你看了&lt;&lt;利用Python进行数据分析&gt;&gt;</p></li></ul><p>这个应该就是半年的学习计划了,对应未来,需要抱有希望,同时做好准备.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;要年终总结了, 翻出来旧的blog, 擦擦灰,看看以前写了写啥.总结下去年一年做了那些工作,学习了那些内容,生活里有那些改变.想想家人,想想自己.同时把新的blog迁移到这里,快过年了,也是新年新气象.祝愿2018年在逆境中一切顺利.&lt;/p&gt;
&lt;p&gt;2017年工作和学习都比较焦虑,去年开始接触公司的后台开发了的, 今年刚开始,想着更进一步学后台的 然而公司人事变动,这个想法也不了了之了.&lt;/p&gt;
&lt;p&gt;上半年公司老板拍脑袋决定要重构系统,其实是想用微服务来重写系统,然后CTO不干了,5月份离职,然后就是裁人招人裁人,新系统还部分外包,旧系统继续运行,继续接需求,一团糟.结果到年底,钱烧了, 新系统也出不来,然后拉投资, 投资也没拉进来.又开始想各种办法省钱, 折腾的不行.&lt;/p&gt;
&lt;p&gt;我的工作依然是android端app.&lt;/p&gt;
&lt;p&gt;夏天时, 给我任务独立开发了2个小app.然后还有一个蓝牙的SDK包.&lt;/p&gt;
&lt;p&gt;十一没有放假, 紧急接了一个演示app,4个人android/ios两端大概1个来星期完成.从公司强要了加班费,还不愿意给.&lt;/p&gt;
    
    </summary>
    
    
      <category term="生活" scheme="http://newyearwang.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="年终总结" scheme="http://newyearwang.com/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
      <category term="闲文" scheme="http://newyearwang.com/tags/%E9%97%B2%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>2017年的生活</title>
    <link href="http://newyearwang.com/2018/01/30/2017%E5%B9%B4%E7%9A%84%E7%94%9F%E6%B4%BB/"/>
    <id>http://newyearwang.com/2018/01/30/2017年的生活/</id>
    <published>2018-01-30T04:55:35.000Z</published>
    <updated>2019-09-07T07:19:59.004Z</updated>
    
    <content type="html"><![CDATA[<p>2017上半年过的很快,简简和奶奶都回老家了.</p><p>我一个人在北京没什么事,所以也经常回老家去看看, 一整年回家的次数不少, 差不多半个月回家一次.</p><p>过完年没多久奶奶就让简简去村里的幼儿园了,这个我是不同意去的.</p><p>在老家一直咳嗽不好, 四月初还到武汉儿童医院去看病了, 在那里打了次吊瓶,也没怎么缓解问题.回家之后还是一直生病.</p><p>五一回家的时候,明显感觉瘦了很多, 和他一起出去玩,也是没精打采.六一之前, 简简理了光头,和小胖一起玩熟悉了,也开始喜欢幼儿园了.</p><p>然后是七月份,简简和奶奶还有美美一起来北京我这里小住一个来月,美美在北京过生日了.中间去了动物园,奥森公园,还有北海公园,拍了蛮多照片.在北京这一个多月里, 奶奶也是各种生病, 八月份中旬就又都回去了,惦记着田里的花生快要成熟了.</p><a id="more"></a><p>然后到十月十一月份,简简在老家就非常喜欢幼儿园了, 虽然总是和小胖打架,但是有好吃的,也总是记得要给小胖分一个,幼儿园放学了,总是他记着把两个人的水瓶衣服都拿上.</p><p>十二月份开始,天气冷了,简简就开始感冒咳嗽不好,在老家住院了一次,出院了,然后又咳嗽发烧,然后只好送到武汉妇幼,在这里打吊瓶一个多星期才好,奶奶一直陪着.<br>在武汉治疗结束,回老家,刚刚好奶奶过五十九岁生日,过完生日第二天,带上美美,还有奶奶,还有简简都到北京来了.</p><p>在北京, 两个小朋友不好好吃饭. 奶奶喂完一个然后又喂另一个,这段时间,简简也开始胖起来了,抱一会儿手就酸得不行.</p><p>对了,12月底的时候,还出去相亲来着,女方是个美容院老板,比我强,然后就没然后了.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2017上半年过的很快,简简和奶奶都回老家了.&lt;/p&gt;
&lt;p&gt;我一个人在北京没什么事,所以也经常回老家去看看, 一整年回家的次数不少, 差不多半个月回家一次.&lt;/p&gt;
&lt;p&gt;过完年没多久奶奶就让简简去村里的幼儿园了,这个我是不同意去的.&lt;/p&gt;
&lt;p&gt;在老家一直咳嗽不好, 四月初还到武汉儿童医院去看病了, 在那里打了次吊瓶,也没怎么缓解问题.回家之后还是一直生病.&lt;/p&gt;
&lt;p&gt;五一回家的时候,明显感觉瘦了很多, 和他一起出去玩,也是没精打采.六一之前, 简简理了光头,和小胖一起玩熟悉了,也开始喜欢幼儿园了.&lt;/p&gt;
&lt;p&gt;然后是七月份,简简和奶奶还有美美一起来北京我这里小住一个来月,美美在北京过生日了.中间去了动物园,奥森公园,还有北海公园,拍了蛮多照片.在北京这一个多月里, 奶奶也是各种生病, 八月份中旬就又都回去了,惦记着田里的花生快要成熟了.&lt;/p&gt;
    
    </summary>
    
    
      <category term="生活" scheme="http://newyearwang.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="年终总结" scheme="http://newyearwang.com/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
      <category term="闲文" scheme="http://newyearwang.com/tags/%E9%97%B2%E6%96%87/"/>
    
  </entry>
  
</feed>
